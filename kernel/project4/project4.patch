diff --git a/slob.c b/Users/ksteinfeldt/Desktop/xfers/xfers/slob.c
index d0e0822..96a8620 100644
--- a/slob.c
+++ b/Users/ksteinfeldt/Desktop/xfers/xfers/slob.c
@@ -72,9 +72,6 @@
 
 #include <linux/atomic.h>
 
-#include <linux/syscalls.h>
-#include <linux/linkage.h>
-
 #include "slab.h"
 /*
  * slob_block has a field 'units', which indicates size of block if +ve,
@@ -90,12 +87,6 @@ typedef s16 slobidx_t;
 typedef s32 slobidx_t;
 #endif
 
-// required vars
-unsigned long pcount = 0;
-unsigned long free = 0;
-int used_m = 0;
-int claimed_m = 0;
-
 struct slob_block {
 	slobidx_t units;
 };
@@ -277,13 +268,10 @@ static void *slob_page_alloc(struct page *sp, size_t size, int align)
 static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 {
 	struct page *sp;
-    struct page *sp_alt;
-    struct list_head *temp;
 	struct list_head *prev;
 	struct list_head *slob_list;
 	slob_t *b = NULL;
 	unsigned long flags;
-    free = 0;
 
 	if (size < SLOB_BREAK1)
 		slob_list = &free_slob_small;
@@ -308,56 +296,19 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 			continue;
 
 		/* Attempt to alloc */
-        /** | Don't want to attempt to alloc yet
 		prev = sp->lru.prev;
 		b = slob_page_alloc(sp, size, align);
 		if (!b)
 			continue;
-         **/
-        
-        if (sp_alt == NULL)
-        {
-            sp_alt = sp;
-        }
 
 		/* Improve fragment distribution and reduce our average
 		 * search time by starting our next search here. (see
 		 * Knuth vol 1, sec 2.5, pg 449) */
-		/** | We don't want this here
-        if (prev != slob_list->prev &&
+		if (prev != slob_list->prev &&
 				slob_list->next != prev->next)
 			list_move_tail(slob_list, prev->next);
 		break;
-         **/
-        // look for smallest possible page
-        if (sp->units < sp_alt->units) {
-            sp_alt = sp;
-        }
 	}
-    // attempt to allocate
-    if (sp_alt != NULL)
-    {
-        b = slob_page_alloc(sp_alt, size, align);
-    }
-    
-    // iterate through small list
-    temp = &free_slob_small;
-    list_for_each_entry(sp, temp, list) {
-        free += sp->units;
-    }
-    
-    // iterate through medium list
-    temp = &free_slob_medium;
-    list_for_each_entry(sp, temp, list) {
-        free += sp->units;
-    }
-    
-    // iterate through large list
-    temp = &free_slob_large;
-    list_for_each_entry(sp, temp, list) {
-        free += sp->units;
-    }
-    
 	spin_unlock_irqrestore(&slob_lock, flags);
 
 	/* Not enough space: must allocate a new page */
@@ -377,16 +328,9 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)
 		b = slob_page_alloc(sp, size, align);
 		BUG_ON(!b);
 		spin_unlock_irqrestore(&slob_lock, flags);
-        
-        // account for new page
-        pcount++;
-        claimed_m += PAGE_SIZE;
 	}
 	if (unlikely((gfp & __GFP_ZERO) && b))
 		memset(b, 0, size);
-    
-    used_m += size;
-    
 	return b;
 }
 
@@ -407,8 +351,6 @@ static void slob_free(void *block, int size)
 
 	sp = virt_to_page(block);
 	units = SLOB_UNITS(size);
-    
-    used_m -= size;
 
 	spin_lock_irqsave(&slob_lock, flags);
 
@@ -420,7 +362,6 @@ static void slob_free(void *block, int size)
 		__ClearPageSlab(sp);
 		page_mapcount_reset(sp);
 		slob_free_pages(b, 0);
-        pcount--;
 		return;
 	}
 
@@ -699,15 +640,3 @@ void __init kmem_cache_init_late(void)
 {
 	slab_state = FULL;
 }
-
-asmlinkage long sys_slob_free(void)
-{
-    free_mem = claimed_m - used_m;
-    return free_mem;
-}
-
-asmlinkage long sys_slob_used(void)
-{
-    return claimed_m;
-}
-
diff --git a/syscall_32.tbl b/Users/ksteinfeldt/Desktop/xfers/xfers/syscall_32.tbl
index 2b9e11f..b3560ec 100644
--- a/syscall_32.tbl
+++ b/Users/ksteinfeldt/Desktop/xfers/xfers/syscall_32.tbl
@@ -365,5 +365,3 @@
 356	i386	memfd_create		sys_memfd_create
 357	i386	bpf			sys_bpf
 358	i386	execveat		sys_execveat			stub32_execveat
-500	i386	slob_free		sys_slob_free
-501	i386	slob_used		sys_slob_used
diff --git a/syscalls.h b/Users/ksteinfeldt/Desktop/xfers/xfers/syscalls.h
index ad5c86c..85893d7 100644
--- a/syscalls.h
+++ b/Users/ksteinfeldt/Desktop/xfers/xfers/syscalls.h
@@ -882,8 +882,4 @@ asmlinkage long sys_execveat(int dfd, const char __user *filename,
 			const char __user *const __user *argv,
 			const char __user *const __user *envp, int flags);
 
-asmlinkage long sys_slob_free(void);
-
-asmlinkage long sys_slob_use(void);
-
 #endif
